# MiniToolbox 插件开发指南

## 概述

MiniToolbox 提供了完整的插件生态系统，支持插件的开发、打包（.mtpkg）、分发（注册中心/离线包）与安装（商店/开发者工具）。本文档整合了开发到安装全流程说明。

## 快速开始

### 1. 创建新插件

使用插件生成器快速创建插件模板：

```bash
# 交互式创建
node tools/plugin-generator.js create

# 指定参数创建
node tools/plugin-generator.js create \
  --id my-plugin \
  --name "我的插件" \
  --description "这是一个示例插件" \
  --author "Your Name" \
  --template ui
```

### 2. 插件结构

```
my-plugin/
├── plugin.json    # 插件配置文件（必需）
├── index.html     # UI插件的界面文件
├── script.js      # 无UI插件的逻辑文件
├── icon.png       # 插件图标（可选）
└── README.md      # 说明文档（推荐）
```

## 插件配置 (plugin.json)

### 基本配置

```json
{
  "name": "我的插件",
  "description": "插件功能描述",
  "version": "1.0.0",
  "author": "作者名称",
  "logo": "🔧",
  "features": [
    {
      "code": "my-plugin.action",
      "explain": "执行某个操作",
      "cmds": [
        {
          "type": "keyword",
          "value": "mykey"
        }
      ]
    }
  ]
}
```

**注意**：不再需要手动指定 `id` 字段，系统会自动生成唯一标识符。

## 插件ID系统

MiniToolbox 采用智能的三层ID管理系统，完全解决了ID冲突问题：

### ID生成机制

1. **本地开发阶段**
   - 使用插件目录名作为ID（如 `json-formatter`）
   - 仅在本地环境中使用，可能存在重复

2. **打包阶段**
   - 生成格式：`目录名-内容哈希`（如 `json-formatter-a1b2c3d4`）
   - 基于插件内容生成8位哈希，确保相同内容产生相同ID
   - 内容变化时哈希也会变化，自动版本控制

3. **发布阶段**
   - 注册中心分配全局唯一ID（如 `reg_1234567890_abcdef`）
   - 绝对唯一，避免任何冲突可能

### 开发者优势

- ✅ **零配置**：无需考虑ID命名和冲突
- ✅ **自动唯一**：系统保证在每个阶段的唯一性
- ✅ **内容感知**：相同内容始终生成相同ID
- ✅ **向后兼容**：现有插件自动适配新系统

### UI插件配置

UI插件需要添加窗口配置：

```json
{
  "window": {
    "width": 800,
    "height": 600,
    "resizable": true,
    "minWidth": 600,
    "minHeight": 400
  }
}
```

### 命令匹配配置

支持多种命令匹配方式：

```json
{
  "features": [
    {
      "code": "feature.code",
      "explain": "功能说明",
      "cmds": [
        {
          "type": "keyword",
          "value": "关键词"
        },
        {
          "type": "regex",
          "match": "/^https?:\\/\\//i"
        },
        {
          "type": "prefix",
          "value": "prefix:"
        }
      ]
    }
  ]
}
```

## 插件类型

### 1. 无UI插件 (script.js)

无UI插件通过 `script.js` 文件实现逻辑，适合后台处理任务。

```javascript
module.exports = {
  'my-plugin.action': {
    async handleEnter(action, callbackSetList) {
      const { payload, type } = action;
      
      // 处理逻辑
      const result = await processData(payload);
      
      // 返回结果列表
      callbackSetList([{
        title: '处理结果',
        description: result,
        data: { result }
      }]);
    },

    async handleSelect(action, itemData, callbackSetList) {
      // 处理用户选择
      if (itemData.data) {
        // 复制结果到剪贴板
        const { clipboard } = require('electron');
        clipboard.writeText(itemData.data.result);
      }
    }
  }
};

async function processData(input) {
  // 实现你的处理逻辑
  return `处理结果: ${input}`;
}
```

### 2. UI插件 (index.html)

UI插件提供图形界面，适合复杂交互。

```html
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>我的插件</title>
  <style>
    /* 插件样式 */
  </style>
</head>
<body>
  <div id="app">
    <!-- 插件界面 -->
  </div>

  <script>
    const api = window.MT;

    // 监听插件输入
    window.addEventListener('plugin-input', (event) => {
      const inputData = event.detail;
      console.log('收到输入:', inputData);
      // 处理输入数据
    });

    // 使用插件API
    async function useAPI() {
      // 读取剪贴板
      const result = await api.invoke('mt.secure-call', {
        channel: 'clipboard.readText'
      });
      
      if (result.ok) {
        console.log('剪贴板内容:', result.data);
      }
    }
  </script>
</body>
</html>
```

## 插件API

### 安全调用接口

通过 `window.MT.invoke(channel, payload)` 调用受限 API：

```javascript
// 剪贴板
await window.MT.invoke('clipboard.readText');
await window.MT.invoke('clipboard.writeText', 'text to copy');

// 打开外部链接
await window.MT.invoke('openExternal', 'https://example.com');

// 网络请求
await window.MT.invoke('net.request', { hostname: 'api.example.com', path: '/data', method: 'GET' });
```

### 主题支持

获取当前主题信息：

```javascript
const res = await window.MT.invoke('ui.getTheme');
const { theme, effective } = res;
```

## 开发与本地运行

### 1. 开发阶段

1. 创建插件目录到 `plugins/` 下，或任意本地目录
2. 编写插件代码（`plugin.json`、`index.html`/`script.js`）
3. 打开插件“开发者工具”
   - 选择 `plugin.json` → 挂载运行（无需复制/重启）
   - 可暂停/卸载开发态插件
4. 需要时使用“重新加载插件”重建索引

### 2. 验证插件

```bash
node tools/plugin-packager.js validate ./plugins/my-plugin
```

### 3. 打包与分发（.mtpkg）

```bash
# 打包单个插件
node tools/plugin-packager.js pack ./plugins/my-plugin ./dist

# 批量打包所有插件
node tools/plugin-packager.js pack-all ./plugins ./dist
```

在“开发者工具”中也可一键打包 `.mtpkg`，分发给他人，使用“从文件安装”即可安装。

### 4. 发布插件（注册中心）

```bash
# 设置API密钥
export PLUGIN_API_KEY="your-api-key"

# 发布插件
node tools/publish-plugin.js publish ./plugins/my-plugin

# 批量发布
node tools/publish-plugin.js publish-all ./plugins
```

## 最佳实践

### 1. 错误处理

```javascript
async handleEnter(action, callbackSetList) {
  try {
    const result = await processData(action.payload);
    callbackSetList([{
      title: '成功',
      description: result,
      data: { result }
    }]);
  } catch (error) {
    callbackSetList([{
      title: '处理失败',
      description: error.message,
      data: null
    }]);
  }
}
```

### 2. 输入验证

```javascript
async handleEnter(action, callbackSetList) {
  const { payload, type } = action;
  
  if (!payload || payload.trim().length === 0) {
    callbackSetList([{
      title: '错误',
      description: '输入不能为空',
      data: null
    }]);
    return;
  }
  
  // 继续处理...
}
```

### 3. 性能优化

- 避免阻塞主线程的长时间操作
- 使用异步操作处理耗时任务
- 合理使用缓存减少重复计算

### 4. 用户体验

- 提供清晰的操作反馈
- 支持键盘快捷键
- 保持界面简洁直观

## 调试技巧

### 1. 控制台输出

```javascript
console.log('调试信息:', data);
console.error('错误信息:', error);
```

### 2. 开发者工具

在开发模式下，可以为插件窗口打开开发者工具：

```javascript
// 在插件中触发开发者工具
if (process.env.NODE_ENV === 'development') {
  // 调试代码
}
```

### 3. 日志记录

```javascript
// 记录插件操作日志
const logAction = (action, data) => {
  console.log(`[${new Date().toISOString()}] ${action}:`, data);
};
```

## 示例插件

### 文本处理插件

```javascript
module.exports = {
  'text-processor.uppercase': {
    async handleEnter(action, callbackSetList) {
      const { payload } = action;
      const result = payload.toUpperCase();
      
      callbackSetList([{
        title: '转换为大写',
        description: result,
        data: { result }
      }]);
    },

    async handleSelect(action, itemData, callbackSetList) {
      if (itemData.data) {
        const { clipboard } = require('electron');
        clipboard.writeText(itemData.data.result);
      }
    }
  }
};
```

### URL工具插件

```javascript
module.exports = {
  'url-tool.open': {
    async handleEnter(action, callbackSetList) {
      const { payload } = action;
      
      if (!/^https?:\/\//.test(payload)) {
        callbackSetList([{
          title: '无效URL',
          description: '请输入有效的URL地址',
          data: null
        }]);
        return;
      }
      
      callbackSetList([{
        title: '打开链接',
        description: payload,
        data: { url: payload }
      }]);
    },

    async handleSelect(action, itemData, callbackSetList) {
      if (itemData.data && itemData.data.url) {
        const { shell } = require('electron');
        await shell.openExternal(itemData.data.url);
      }
    }
  }
};
```

## 常见问题

### Q: 插件如何访问本地文件？

A: 出于安全考虑，插件无法直接访问本地文件系统。如需文件操作，请通过插件API或在主进程中实现相关功能。

### Q: 如何实现插件间通信？

A: 可以通过 `redirect` 函数重定向到其他插件：

```javascript
action.redirect('target-plugin-id', 'input content');
```

### Q: 插件如何持久化数据？

A: 建议使用 localStorage 或通过插件API调用主进程的数据存储功能。

### Q: 如何处理异步操作？

A: 使用 async/await 或 Promise 处理异步操作，确保在回调中返回结果。

## 更多资源

- [插件API参考](./PLUGIN_API.md)
- [示例插件集合](../examples/)
- [常见问题解答](./FAQ.md)
- [社区讨论](https://github.com/minitoolbox/discussions)

---

如有问题或建议，欢迎在 GitHub 上提交 Issue 或 Pull Request！
